Mini EP 2: Verificação usando Pthreads

Foi escrito um programa em C que simula o "frog puzzle". Ele recebe M e N como parâmetros de entrada. Um vetor de tamanho M+N+1 representa o estado de uma lagoa (com M+N+1 pedras). Inicialmente, há M pedras com sapos no começo do vetor, N pedras com rãs no final do vetor, e uma pedra vazia entre eles. Cada animal é representado por uma thread que fica tentando se mover entre as pedras da lagoa.

Na primeira versão do programa, foram definidas seções críticas bem pequenas dentro de getters e setters das variáveis compartilhadas. Observou-se que, mesmo com frequência bem baixa, ocorreram estados inválidos (por exemplo, estados com duas pedras vazias e um animal desaparecido). Havia seções críticas dentro dos setters/getters e dentro de desvios (por exemplo, if(get_lake_position == EMPTY) set_lake_position), o que possibilitava conflito entre threads num timing bem específico entre a verificação da variável e a atualização da variável. A solução para isso foi definir uma única seção crítica que englobasse todos os desvios que dependessem das variáveis compartilhadas. Embora sejam seções críticas com blocos de código maiores, a versão corrigida tem tempo de execução da mesma ordem que a primeira versão.

Com auxílio do utilitário perf, disponível no Linux, o programa foi testado usando valores diferentes para o limite do contador global, rodando 1000 vezes para cada valor (alternativamente, poderia se fazer um laço dentro com o número desejado de rodadas dentro do próprio programa). O primeiro valor testado para o limite do contador global foi 1000 (para M=N=5). Com esses valores, o estado final foi igual ao inicial com uma frequência alta, o que indica que os animais que poderiam se mover nem tinham conseguido tentar. O limite foi aumentado até 10^5, valor em que a frequência de estados finais incorretos (em que algum animal ainda poderia se mover) é da ordem de 1%. É um valor adequado para se dizer que houve deadlock com probablidade alta e sem perda de desempenho. Observou-se, porém, que esse limite não era suficiente quando M e N eram aumentados. Então, adotou-se 10^4*(M+N) como limite. Esse valor foi testado com parâmetros de entrada diversos e funcionou bem.

Após definir o limite do contador global, foi incluído o segundo controle de final de processo, o árbitro, que é uma thread adicional que verifica o estado da lagoa para detectar deadlocks. Na maior parte das rodadas, é o árbitro que finaliza o processo, quando o contador ainda está algumas ordens de grandeza menor que o limite. Há alguns casos raros, entretanto, em que o limite é atingido; logo, os dois controles de final de processo são complementares.