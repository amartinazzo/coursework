Mini EP 2: Hyperthreading

Foi escrito um programa em C que faz um cálculo computacionalmente caro (neste caso, multiplicação de matrizes) com três versões diferentes: 1) usando múltiplas threads ao mesmo tempo, 2) usando um número de threads igual ao número de cores, 3) usando uma única thread (ou seja, computando tudo sequencialmente). O programa foi testado num Intel i3, que tem dois cores físicos, e quatro cores virtuais (em modo hyperthreading). Os parâmetros que podem ser alterados para observar o comportamento de cada versão são: o tamanho das matrizes N (que são quadradas), e a quantidade de cálculos a serem feitos n_calc (equivalente ao número de threads em modo hyperthreading).

Para matrizes pequenas (N=~50) e poucos cálculos (n_calc=~10), verificou-se que a versão 2 é apenas ligeiramente mais rápida que as demais. Para matrizes pequenas (N=50) e muitos cálculos (n_calc=300), a versão 2 é duas vezes mais rápida que a versão 3, e três vezes mais rápida que a versão 1. Ao aumentar o tamanho das matrizes também, as versões 2 (que usa duas threads) e 3 (que usa uma única thread) ficam com tempos de execução equivalentes. Esperava-se que a versão 2 continuasse mais rápida, mas isso não foi verificado. Uma explicação possível é que, para quantidades maiores de dados, o gerenciamento do cachê seria mais eficiente com uma única thread (não há problemas de invalidação de cachê, por exemplo).

A versão 1 (que usa hyperthreading) é a mais lenta de todas. Nos piores casos (com N e n_calc grandes), ela demora o dobro do tempo das demais. Este é o comportamento que queríamos detectar: fica evidente que, para cálculos custosos, o uso de hyperthreading não é vantajoso.
